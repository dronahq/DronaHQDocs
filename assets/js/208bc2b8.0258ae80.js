"use strict";(self.webpackChunkdronahq_docs=self.webpackChunkdronahq_docs||[]).push([[57912],{56047:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>f,frontMatter:()=>o,metadata:()=>u,toc:()=>d});a(67294);var n=a(3905);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))})),e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}const o={sidebar_position:2,title:"SQL Templating"},s=void 0,u={unversionedId:"dashboard-dronahq/working-with-data/sql-templating",id:"dashboard-dronahq/working-with-data/sql-templating",title:"SQL Templating",description:"Jinja Templates",source:"@site/docs/dashboard-dronahq/working-with-data/sql-templating.md",sourceDirName:"dashboard-dronahq/working-with-data",slug:"/dashboard-dronahq/working-with-data/sql-templating",permalink:"/dashboard-dronahq/working-with-data/sql-templating",draft:!1,tags:[],version:"current",lastUpdatedAt:1723633308,formattedLastUpdatedAt:"Aug 14, 2024",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"SQL Templating"},sidebar:"docSidebar",previous:{title:"SQL - Query & Analysis",permalink:"/dashboard-dronahq/working-with-data/sql-labs"},next:{title:"Table Visualization for Dataset",permalink:"/dashboard-dronahq/working-with-data/table-visualization-dataset"}},c={},d=[{value:"Jinja Templates",id:"jinja-templates",level:2},{value:"Custom Template Processors",id:"custom-template-processors",level:4},{value:"SQL Validation",id:"sql-validation",level:4},{value:"Predefined Jinja Macros",id:"predefined-jinja-macros",level:4},{value:"Current Username",id:"current-username",level:5},{value:"Current User ID",id:"current-user-id",level:5},{value:"Current User Email",id:"current-user-email",level:5},{value:"Custom URL Parameters",id:"custom-url-parameters",level:5},{value:"Explicitly Including Values in Cache Key",id:"explicitly-including-values-in-cache-key",level:5},{value:"Filter Values",id:"filter-values",level:5},{value:"Filters for a Specific Column",id:"filters-for-a-specific-column",level:5},{value:"Querying Datasets",id:"querying-datasets",level:4},{value:"Metrics",id:"metrics",level:4}],p={toc:d},m="wrapper";function f(e){var{components:t}=e,a=i(e,["components"]);return(0,n.kt)(m,l(function(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{},n=Object.keys(a);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(a).filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable})))),n.forEach((function(t){r(e,t,a[t])}))}return e}({},p,a),{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h2",{id:"jinja-templates"},"Jinja Templates"),(0,n.kt)("p",null,"In Dashboard's SQL Lab Editor, Jinja templating is supported within queries. To activate templating, you need to enable the ",(0,n.kt)("inlineCode",{parentName:"p"},"ENABLE_TEMPLATE_PROCESSING")," feature in your DronaHQ configuration. Once enabled, you can embed Python code within virtual datasets and Custom SQL, particularly in filter and metric controls in the Explore interface."),(0,n.kt)("p",null,"By default, the following variables are accessible within the Jinja context:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"columns"),": Columns used for grouping in the query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"filter"),": Filters applied in the query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"from_dttm"),": Start datetime of the selected time range (None if not defined)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"to_dttm"),": End datetime of the selected time range (None if not defined)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"groupby"),": Deprecated; columns used for grouping in the query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"metrics"),": Aggregate expressions in the query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"row_limit"),": Row limit of the query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"row_offset"),": Row offset of the query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"table_columns"),": Columns available in the dataset"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"time_column"),": Temporal column of the query (None if not defined)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"time_grain"),": Selected time grain (None if not defined)")),(0,n.kt)("p",null,"For instance, to apply a time range filter in a virtual dataset, you can write:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT *\nFROM tbl\nWHERE dttm_col > '{{ from_dttm }}' AND dttm_col < '{{ to_dttm }}'\n")),(0,n.kt)("p",null,"Additionally, you can use Jinja logic to ensure your query handles scenarios where the time range filter might be cleared:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT *\nFROM tbl\nWHERE (\n    {% if from_dttm is not none %}\n        dttm_col > '{{ from_dttm }}' AND\n    {% endif %}\n    {% if to_dttm is not none %}\n        dttm_col < '{{ to_dttm }}' AND\n    {% endif %}\n    true\n)\n")),(0,n.kt)("p",null,"Notice that Jinja parameters are invoked with double brackets in the query and without brackets in the logic blocks."),(0,n.kt)("p",null,"To introduce custom functionality into the Jinja context, you can extend the default context by defining ",(0,n.kt)("inlineCode",{parentName:"p"},"JINJA_CONTEXT_ADDONS")," in your configuration. The objects in this dictionary are then available for use where Jinja templating is supported."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"JINJA_CONTEXT_ADDONS = {\n    'my_custom_macro': lambda x: x * 2,\n}\n")),(0,n.kt)("p",null,"Default values for Jinja templates can be set through the Parameters menu in the SQL Lab interface. Parameters are assigned as a JSON object and become accessible in your SQL code using Jinja syntax."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "my_table": "foo"\n}\n')),(0,n.kt)("p",null,"You can then refer to these parameters in your queries:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM {{ my_table }}\n")),(0,n.kt)("p",null,"These parameters are stored with the dataset as TEMPLATE PARAMETERS."),(0,n.kt)("p",null,"There's a special ",(0,n.kt)("inlineCode",{parentName:"p"},"_filters")," parameter that allows testing filters used within the Jinja template."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "_filters": [\n    {\n      "col": "action_type",\n      "op": "IN",\n      "val": ["sell", "buy"]\n    }\n  ]\n}\n')),(0,n.kt)("p",null,"For example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT action, count(*) as times\nFROM logs\nWHERE action in {{ filter_values('action_type') | where_in }}\nGROUP BY action\n")),(0,n.kt)("p",null,"Note that ",(0,n.kt)("inlineCode",{parentName:"p"},"_filters")," is not stored with the dataset and is only used within the SQL Lab interface."),(0,n.kt)("h4",{id:"custom-template-processors"},"Custom Template Processors"),(0,n.kt)("p",null,"Besides default Jinja templating, SQL Lab supports custom template processors. You can define your own template processor by setting the ",(0,n.kt)("inlineCode",{parentName:"p"},"CUSTOM_TEMPLATE_PROCESSORS")," configuration. This allows you to override the default Jinja template processors for specific database connector. For instance, you could create a custom template processor for Presto that uses a different syntax, such as ",(0,n.kt)("inlineCode",{parentName:"p"},"$")," instead of Jinja\u2019s ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ }}"),"."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},'def DATE(ts: datetime, day_offset: int = 0, hour_offset: int = 0) -> str:\n    offset_day = (ts + timedelta(days=day_offset, hours=hour_offset)).date()\n    return str(offset_day)\n\nclass CustomPrestoTemplateProcessor(PrestoTemplateProcessor):\n    engine = "presto"\n\n    def process_template(self, sql: str, `kwargs) -> str:\n        macros = {\n            "DATE": partial(DATE, datetime.utcnow())\n        }\n        macros.update(self.context)\n        macros.update(kwargs)\n\n        def replacer(match):\n            macro_name, args_str = match.groups()\n            args = [a.strip() for a in args_str.split(",")]\n            f = macros[macro_name[1:]]\n            return f(*args)\n\n        macro_names = ["$" + name for name in macros.keys()]\n        pattern = r"(%s)\\s*\\(([^()]*)\\)" % "|".join(map(re.escape, macro_names))\n        return re.sub(pattern, replacer, sql)\n\nCUSTOM_TEMPLATE_PROCESSORS = {\n    CustomPrestoTemplateProcessor.engine: CustomPrestoTemplateProcessor\n}\n')),(0,n.kt)("h4",{id:"sql-validation"},"SQL Validation"),(0,n.kt)("p",null,"SQL Lab also includes live query validation with pluggable backends. You can specify which validation implementation to use for different database connectors by configuring the ",(0,n.kt)("inlineCode",{parentName:"p"},"SQL_VALIDATORS_BY_ENGINE")," in your configuration file:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"FEATURE_FLAGS = {\n    'SQL_VALIDATORS_BY_ENGINE': {\n        'presto': 'PrestoDBSQLValidator',\n    }\n}\n")),(0,n.kt)("p",null,"The available validators and their names can be found in the ",(0,n.kt)("inlineCode",{parentName:"p"},"sql_validators")," module."),(0,n.kt)("h4",{id:"predefined-jinja-macros"},"Predefined Jinja Macros"),(0,n.kt)("h5",{id:"current-username"},"Current Username"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ current_username() }}")," macro retrieves the username of the currently logged-in user. If caching is enabled, this value is used by default in the cache key calculation. To exclude the username from the cache key, use:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-jinja"},"{{ current_username(add_to_cache_keys=False) }}\n")),(0,n.kt)("h5",{id:"current-user-id"},"Current User ID"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ current_user_id() }}")," macro returns the ID of the currently logged-in user. Like the username, this value is included in the cache key by default. To exclude it:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-jinja"},"{{ current_user_id(add_to_cache_keys=False) }}\n")),(0,n.kt)("h5",{id:"current-user-email"},"Current User Email"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ current_user_email() }}")," macro retrieves the email address of the currently logged-in user, which is also included in the cache key by default. To exclude it:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-jinja"},"{{ current_user_email(add_to_cache_keys=False) }}\n")),(0,n.kt)("h5",{id:"custom-url-parameters"},"Custom URL Parameters"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ url_param('custom_variable') }}")," macro allows you to define and reference arbitrary URL parameters in your SQL code."),(0,n.kt)("p",null,"For example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT count(*)\nFROM ORDERS\nWHERE country_code = '{{ url_param('countrycode') }}'\n")),(0,n.kt)("p",null,"This query will adapt based on the ",(0,n.kt)("inlineCode",{parentName:"p"},"countrycode")," parameter passed in the URL."),(0,n.kt)("h5",{id:"explicitly-including-values-in-cache-key"},"Explicitly Including Values in Cache Key"),(0,n.kt)("p",null,"Use the ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ cache_key_wrapper() }}")," function to explicitly include a value in the cache key calculation. This is useful for custom functions that return values that need to be included in the cache key."),(0,n.kt)("h5",{id:"filter-values"},"Filter Values"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ filter_values() }}")," macro retrieves the value of a specific filter as a list, which is useful for queries where the filter component column name differs from the one in the select statement."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT action, count(*) as times\nFROM logs\nWHERE action in {{ filter_values('action_type') | where_in }}\nGROUP BY action\n")),(0,n.kt)("h5",{id:"filters-for-a-specific-column"},"Filters for a Specific Column"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ get_filters() }}")," macro returns filters applied to a given column, including the operator used in the Explore UI. This is useful for handling custom SQL conditions for filters or when the filter inside the main query needs to be optimized for performance."),(0,n.kt)("p",null,"For example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"WITH RECURSIVE\n    superiors(employee_id, manager_id, full_name, level, lineage) AS (\n    SELECT\n        employee_id,\n        manager_id,\n        full_name,\n        1 as level,\n        employee_id as lineage\n    FROM\n        employees\n    WHERE 1=1\n    {%- for filter in get_filters('full_name', remove_filter=True) -%}\n        {%- if filter.get('op') == 'IN' -%}\n            AND full_name IN {{ filter.get('val') | where_in }}\n        {%- elif filter.get('op') == 'LIKE' -%}\n            AND full_name LIKE {{ \"'\" + filter.get('val') + \"'\" }}\n        {%- endif -%}\n    {%- endfor -%}\n    UNION ALL\n    SELECT\n        e.employee_id,\n        e.manager_id,\n        e.full_name,\n        s.level + 1 as level,\n        s.lineage\n    FROM\n        employees e, superiors s\n    WHERE s.manager_id = e.employee_id\n    )\nSELECT\n    employee_id, manager_id, full_name, level, lineage\nFROM\n    superiors\nORDER BY lineage, level\n")),(0,n.kt)("h4",{id:"querying-datasets"},"Querying Datasets"),(0,n.kt)("p",null,"You can query both physical and virtual datasets using the ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ dataset() }}")," macro. This is particularly useful when you want to reuse computed columns and metrics in ad-hoc SQL Lab queries."),(0,n.kt)("p",null,"To query a dataset:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM {{ dataset(42) }} LIMIT 10\n")),(0,n.kt)("p",null,"To include metrics in the query:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM {{ dataset(42, include_metrics=True) }} LIMIT 10\n")),(0,n.kt)("p",null,"You can also specify which columns to group by:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},'SELECT * FROM {{ dataset(42, include_metrics=True, columns=["ds", "category"]) }} LIMIT 10\n')),(0,n.kt)("h4",{id:"metrics"},"Metrics"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{{ metric('metric_key', dataset_id) }}")," macro allows you to retrieve metric SQL syntax from a dataset. This is helpful for:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Overriding metric labels at the chart level")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Combining multiple metrics in calculations")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Using existing metrics in ad-hoc SQL queries in SQL Lab"))),(0,n.kt)("p",null,"The metric name is stored in the metric key and typically includes a label for charts or an alias for SQL queries. To use a metric with a custom alias, provide the alias as the third argument:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT SUM(value)\nFROM {{ dataset(42) }}\nWHERE {{ metric('revenue', 42) }} > 0\n")),(0,n.kt)("p",null,"You can also use macros in datasets, metrics, and filters to create dynamic and flexible queries."))}f.isMDXComponent=!0}}]);